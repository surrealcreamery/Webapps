{
  "version": 3,
  "sources": ["../../@tanstack/query-persist-client-core/src/persist.ts", "../../@tanstack/query-persist-client-core/src/retryStrategies.ts", "../../@tanstack/query-persist-client-core/src/createPersister.ts", "../../@tanstack/react-query-persist-client/src/PersistQueryClientProvider.tsx"],
  "sourcesContent": ["import { dehydrate, hydrate } from '@tanstack/query-core'\nimport type {\n  DehydrateOptions,\n  DehydratedState,\n  HydrateOptions,\n  NotifyEventType,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport type Promisable<T> = T | PromiseLike<T>\n\nexport interface Persister {\n  persistClient: (persistClient: PersistedClient) => Promisable<void>\n  restoreClient: () => Promisable<PersistedClient | undefined>\n  removeClient: () => Promisable<void>\n}\n\nexport interface PersistedClient {\n  timestamp: number\n  buster: string\n  clientState: DehydratedState\n}\n\nexport interface PersistQueryClientRootOptions {\n  /** The QueryClient to persist */\n  queryClient: QueryClient\n  /** The Persister interface for storing and restoring the cache\n   * to/from a persisted location */\n  persister: Persister\n  /** A unique string that can be used to forcefully\n   * invalidate existing caches if they do not share the same buster string */\n  buster?: string\n}\n\nexport interface PersistedQueryClientRestoreOptions\n  extends PersistQueryClientRootOptions {\n  /** The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be discarded */\n  maxAge?: number\n  /** The options passed to the hydrate function */\n  hydrateOptions?: HydrateOptions\n}\n\nexport interface PersistedQueryClientSaveOptions\n  extends PersistQueryClientRootOptions {\n  /** The options passed to the dehydrate function */\n  dehydrateOptions?: DehydrateOptions\n}\n\nexport interface PersistQueryClientOptions\n  extends PersistedQueryClientRestoreOptions,\n    PersistedQueryClientSaveOptions,\n    PersistQueryClientRootOptions {}\n\n/**\n * Checks if emitted event is about cache change and not about observers.\n * Useful for persist, where we only want to trigger save when cache is changed.\n */\nconst cacheEventTypes: Array<NotifyEventType> = ['added', 'removed', 'updated']\n\nfunction isCacheEventType(eventType: NotifyEventType) {\n  return cacheEventTypes.includes(eventType)\n}\n\n/**\n * Restores persisted data to the QueryCache\n *  - data obtained from persister.restoreClient\n *  - data is hydrated using hydrateOptions\n * If data is expired, busted, empty, or throws, it runs persister.removeClient\n */\nexport async function persistQueryClientRestore({\n  queryClient,\n  persister,\n  maxAge = 1000 * 60 * 60 * 24,\n  buster = '',\n  hydrateOptions,\n}: PersistedQueryClientRestoreOptions) {\n  try {\n    const persistedClient = await persister.restoreClient()\n\n    if (persistedClient) {\n      if (persistedClient.timestamp) {\n        const expired = Date.now() - persistedClient.timestamp > maxAge\n        const busted = persistedClient.buster !== buster\n        if (expired || busted) {\n          return persister.removeClient()\n        } else {\n          hydrate(queryClient, persistedClient.clientState, hydrateOptions)\n        }\n      } else {\n        return persister.removeClient()\n      }\n    }\n  } catch (err) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(err)\n      console.warn(\n        'Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.',\n      )\n    }\n\n    await persister.removeClient()\n\n    throw err\n  }\n}\n\n/**\n * Persists data from the QueryCache\n *  - data dehydrated using dehydrateOptions\n *  - data is persisted using persister.persistClient\n */\nexport async function persistQueryClientSave({\n  queryClient,\n  persister,\n  buster = '',\n  dehydrateOptions,\n}: PersistedQueryClientSaveOptions) {\n  const persistClient: PersistedClient = {\n    buster,\n    timestamp: Date.now(),\n    clientState: dehydrate(queryClient, dehydrateOptions),\n  }\n\n  await persister.persistClient(persistClient)\n}\n\n/**\n * Subscribe to QueryCache and MutationCache updates (for persisting)\n * @returns an unsubscribe function (to discontinue monitoring)\n */\nexport function persistQueryClientSubscribe(\n  props: PersistedQueryClientSaveOptions,\n) {\n  const unsubscribeQueryCache = props.queryClient\n    .getQueryCache()\n    .subscribe((event) => {\n      if (isCacheEventType(event.type)) {\n        persistQueryClientSave(props)\n      }\n    })\n\n  const unsubscribeMutationCache = props.queryClient\n    .getMutationCache()\n    .subscribe((event) => {\n      if (isCacheEventType(event.type)) {\n        persistQueryClientSave(props)\n      }\n    })\n\n  return () => {\n    unsubscribeQueryCache()\n    unsubscribeMutationCache()\n  }\n}\n\n/**\n * Restores persisted data to QueryCache and persists further changes.\n */\nexport function persistQueryClient(\n  props: PersistQueryClientOptions,\n): [() => void, Promise<void>] {\n  let hasUnsubscribed = false\n  let persistQueryClientUnsubscribe: (() => void) | undefined\n  const unsubscribe = () => {\n    hasUnsubscribed = true\n    persistQueryClientUnsubscribe?.()\n  }\n\n  // Attempt restore\n  const restorePromise = persistQueryClientRestore(props).then(() => {\n    if (!hasUnsubscribed) {\n      // Subscribe to changes in the query cache to trigger the save\n      persistQueryClientUnsubscribe = persistQueryClientSubscribe(props)\n    }\n  })\n\n  return [unsubscribe, restorePromise]\n}\n", "import type { PersistedClient } from './persist'\n\nexport type PersistRetryer = (props: {\n  persistedClient: PersistedClient\n  error: Error\n  errorCount: number\n}) => PersistedClient | undefined\n\nexport const removeOldestQuery: PersistRetryer = ({ persistedClient }) => {\n  const mutations = [...persistedClient.clientState.mutations]\n  const queries = [...persistedClient.clientState.queries]\n  const client: PersistedClient = {\n    ...persistedClient,\n    clientState: { mutations, queries },\n  }\n\n  // sort queries by dataUpdatedAt (oldest first)\n  const sortedQueries = [...queries].sort(\n    (a, b) => a.state.dataUpdatedAt - b.state.dataUpdatedAt,\n  )\n\n  // clean oldest query\n  if (sortedQueries.length > 0) {\n    const oldestData = sortedQueries.shift()\n    client.clientState.queries = queries.filter((q) => q !== oldestData)\n    return client\n  }\n\n  return undefined\n}\n", "import { hashKey, matchQuery, partialMatchKey } from '@tanstack/query-core'\nimport type {\n  Query,\n  QueryClient,\n  QueryFilters,\n  QueryFunctionContext,\n  QueryKey,\n  QueryState,\n} from '@tanstack/query-core'\n\nexport interface PersistedQuery {\n  buster: string\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n}\n\nexport type MaybePromise<T> = T | Promise<T>\n\nexport interface AsyncStorage<TStorageValue = string> {\n  getItem: (key: string) => MaybePromise<TStorageValue | undefined | null>\n  setItem: (key: string, value: TStorageValue) => MaybePromise<unknown>\n  removeItem: (key: string) => MaybePromise<void>\n  entries?: () => MaybePromise<Array<[key: string, value: TStorageValue]>>\n}\n\nexport interface StoragePersisterOptions<TStorageValue = string> {\n  /** The storage client used for setting and retrieving items from cache.\n   * For SSR pass in `undefined`.\n   */\n  storage: AsyncStorage<TStorageValue> | undefined | null\n  /**\n   * How to serialize the data to storage.\n   * @default `JSON.stringify`\n   */\n  serialize?: (persistedQuery: PersistedQuery) => MaybePromise<TStorageValue>\n  /**\n   * How to deserialize the data from storage.\n   * @default `JSON.parse`\n   */\n  deserialize?: (cachedString: TStorageValue) => MaybePromise<PersistedQuery>\n  /**\n   * A unique string that can be used to forcefully invalidate existing caches,\n   * if they do not share the same buster string\n   */\n  buster?: string\n  /**\n   * The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be discarded\n   * @default 24 hours\n   */\n  maxAge?: number\n  /**\n   * Prefix to be used for storage key.\n   * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.\n   * @default 'tanstack-query'\n   */\n  prefix?: string\n  /**\n   * Filters to narrow down which Queries should be persisted.\n   */\n  filters?: QueryFilters\n}\n\nexport const PERSISTER_KEY_PREFIX = 'tanstack-query'\n\n/**\n * Warning: experimental feature.\n * This utility function enables fine-grained query persistence.\n * Simple add it as a `persister` parameter to `useQuery` or `defaultOptions` on `queryClient`.\n *\n * ```\n * useQuery({\n     queryKey: ['myKey'],\n     queryFn: fetcher,\n     persister: createPersister({\n       storage: localStorage,\n     }),\n   })\n   ```\n */\nexport function experimental_createQueryPersister<TStorageValue = string>({\n  storage,\n  buster = '',\n  maxAge = 1000 * 60 * 60 * 24,\n  serialize = JSON.stringify as Required<\n    StoragePersisterOptions<TStorageValue>\n  >['serialize'],\n  deserialize = JSON.parse as Required<\n    StoragePersisterOptions<TStorageValue>\n  >['deserialize'],\n  prefix = PERSISTER_KEY_PREFIX,\n  filters,\n}: StoragePersisterOptions<TStorageValue>) {\n  function isExpiredOrBusted(persistedQuery: PersistedQuery) {\n    if (persistedQuery.state.dataUpdatedAt) {\n      const queryAge = Date.now() - persistedQuery.state.dataUpdatedAt\n      const expired = queryAge > maxAge\n      const busted = persistedQuery.buster !== buster\n\n      if (expired || busted) {\n        return true\n      }\n\n      return false\n    }\n\n    return true\n  }\n\n  async function retrieveQuery<T>(\n    queryHash: string,\n    afterRestoreMacroTask?: (persistedQuery: PersistedQuery) => void,\n  ) {\n    if (storage != null) {\n      const storageKey = `${prefix}-${queryHash}`\n      try {\n        const storedData = await storage.getItem(storageKey)\n        if (storedData) {\n          const persistedQuery = await deserialize(storedData)\n\n          if (isExpiredOrBusted(persistedQuery)) {\n            await storage.removeItem(storageKey)\n          } else {\n            if (afterRestoreMacroTask) {\n              // Just after restoring we want to get fresh data from the server if it's stale\n              setTimeout(() => afterRestoreMacroTask(persistedQuery), 0)\n            }\n            // We must resolve the promise here, as otherwise we will have `loading` state in the app until `queryFn` resolves\n            return persistedQuery.state.data as T\n          }\n        }\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(err)\n          console.warn(\n            'Encountered an error attempting to restore query cache from persisted location.',\n          )\n        }\n        await storage.removeItem(storageKey)\n      }\n    }\n\n    return\n  }\n\n  async function persistQueryByKey(\n    queryKey: QueryKey,\n    queryClient: QueryClient,\n  ) {\n    if (storage != null) {\n      const query = queryClient.getQueryCache().find({ queryKey })\n      if (query) {\n        await persistQuery(query)\n      } else {\n        if (process.env.NODE_ENV === 'development') {\n          console.warn(\n            'Could not find query to be persisted. QueryKey:',\n            JSON.stringify(queryKey),\n          )\n        }\n      }\n    }\n  }\n\n  async function persistQuery(query: Query) {\n    if (storage != null) {\n      const storageKey = `${prefix}-${query.queryHash}`\n      storage.setItem(\n        storageKey,\n        await serialize({\n          state: query.state,\n          queryKey: query.queryKey,\n          queryHash: query.queryHash,\n          buster: buster,\n        }),\n      )\n    }\n  }\n\n  async function persisterFn<T, TQueryKey extends QueryKey>(\n    queryFn: (context: QueryFunctionContext<TQueryKey>) => T | Promise<T>,\n    ctx: QueryFunctionContext<TQueryKey>,\n    query: Query,\n  ) {\n    const matchesFilter = filters ? matchQuery(filters, query) : true\n\n    // Try to restore only if we do not have any data in the cache and we have persister defined\n    if (matchesFilter && query.state.data === undefined && storage != null) {\n      const restoredData = await retrieveQuery(\n        query.queryHash,\n        (persistedQuery: PersistedQuery) => {\n          // Set proper updatedAt, since resolving in the first pass overrides those values\n          query.setState({\n            dataUpdatedAt: persistedQuery.state.dataUpdatedAt,\n            errorUpdatedAt: persistedQuery.state.errorUpdatedAt,\n          })\n\n          if (query.isStale()) {\n            query.fetch()\n          }\n        },\n      )\n\n      if (restoredData != null) {\n        return Promise.resolve(restoredData as T)\n      }\n    }\n\n    // If we did not restore, or restoration failed - fetch\n    const queryFnResult = await queryFn(ctx)\n\n    if (matchesFilter && storage != null) {\n      // Persist if we have storage defined, we use timeout to get proper state to be persisted\n      setTimeout(() => {\n        persistQuery(query)\n      }, 0)\n    }\n\n    return Promise.resolve(queryFnResult)\n  }\n\n  async function persisterGc() {\n    if (storage?.entries) {\n      const entries = await storage.entries()\n      for (const [key, value] of entries) {\n        if (key.startsWith(prefix)) {\n          const persistedQuery = await deserialize(value)\n\n          if (isExpiredOrBusted(persistedQuery)) {\n            await storage.removeItem(key)\n          }\n        }\n      }\n    } else if (process.env.NODE_ENV === 'development') {\n      throw new Error(\n        'Provided storage does not implement `entries` method. Garbage collection is not possible without ability to iterate over storage items.',\n      )\n    }\n  }\n\n  async function restoreQueries(\n    queryClient: QueryClient,\n    filters: Pick<QueryFilters, 'queryKey' | 'exact'> = {},\n  ): Promise<void> {\n    const { exact, queryKey } = filters\n\n    if (storage?.entries) {\n      const entries = await storage.entries()\n      for (const [key, value] of entries) {\n        if (key.startsWith(prefix)) {\n          const persistedQuery = await deserialize(value)\n\n          if (isExpiredOrBusted(persistedQuery)) {\n            await storage.removeItem(key)\n            continue\n          }\n\n          if (queryKey) {\n            if (exact) {\n              if (persistedQuery.queryHash !== hashKey(queryKey)) {\n                continue\n              }\n            } else if (!partialMatchKey(persistedQuery.queryKey, queryKey)) {\n              continue\n            }\n          }\n\n          queryClient.setQueryData(\n            persistedQuery.queryKey,\n            persistedQuery.state.data,\n            {\n              updatedAt: persistedQuery.state.dataUpdatedAt,\n            },\n          )\n        }\n      }\n    } else if (process.env.NODE_ENV === 'development') {\n      throw new Error(\n        'Provided storage does not implement `entries` method. Restoration of all stored entries is not possible without ability to iterate over storage items.',\n      )\n    }\n  }\n\n  return {\n    persisterFn,\n    persistQuery,\n    persistQueryByKey,\n    retrieveQuery,\n    persisterGc,\n    restoreQueries,\n  }\n}\n", "'use client'\nimport * as React from 'react'\n\nimport {\n  persistQueryClientRestore,\n  persistQueryClientSubscribe,\n} from '@tanstack/query-persist-client-core'\nimport { IsRestoringProvider, QueryClientProvider } from '@tanstack/react-query'\nimport type { PersistQueryClientOptions } from '@tanstack/query-persist-client-core'\nimport type { OmitKeyof, QueryClientProviderProps } from '@tanstack/react-query'\n\nexport type PersistQueryClientProviderProps = QueryClientProviderProps & {\n  persistOptions: OmitKeyof<PersistQueryClientOptions, 'queryClient'>\n  onSuccess?: () => Promise<unknown> | unknown\n  onError?: () => Promise<unknown> | unknown\n}\n\nexport const PersistQueryClientProvider = ({\n  children,\n  persistOptions,\n  onSuccess,\n  onError,\n  ...props\n}: PersistQueryClientProviderProps): React.JSX.Element => {\n  const [isRestoring, setIsRestoring] = React.useState(true)\n  const refs = React.useRef({ persistOptions, onSuccess, onError })\n  const didRestore = React.useRef(false)\n\n  React.useEffect(() => {\n    refs.current = { persistOptions, onSuccess, onError }\n  })\n\n  React.useEffect(() => {\n    const options = {\n      ...refs.current.persistOptions,\n      queryClient: props.client,\n    }\n    if (!didRestore.current) {\n      didRestore.current = true\n      persistQueryClientRestore(options)\n        .then(() => refs.current.onSuccess?.())\n        .catch(() => refs.current.onError?.())\n        .finally(() => {\n          setIsRestoring(false)\n        })\n    }\n    return isRestoring ? undefined : persistQueryClientSubscribe(options)\n  }, [props.client, isRestoring])\n\n  return (\n    <QueryClientProvider {...props}>\n      <IsRestoringProvider value={isRestoring}>{children}</IsRestoringProvider>\n    </QueryClientProvider>\n  )\n}\n"],
  "mappings": "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",
  "names": ["filters"]
}
