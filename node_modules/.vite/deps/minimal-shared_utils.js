import "./chunk-4B2QHNJT.js";

// node_modules/es-toolkit/dist/function/noop.mjs
function noop() {
}

// node_modules/es-toolkit/dist/function/partial.mjs
function partial(func, ...partialArgs) {
  return partialImpl(func, placeholderSymbol, ...partialArgs);
}
function partialImpl(func, placeholder, ...partialArgs) {
  const partialed = function(...providedArgs) {
    let providedArgsIndex = 0;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    const remainingArgs = providedArgs.slice(providedArgsIndex);
    return func.apply(this, substitutedArgs.concat(remainingArgs));
  };
  if (func.prototype) {
    partialed.prototype = Object.create(func.prototype);
  }
  return partialed;
}
var placeholderSymbol = Symbol("partial.placeholder");
partial.placeholder = placeholderSymbol;

// node_modules/es-toolkit/dist/function/partialRight.mjs
function partialRight(func, ...partialArgs) {
  return partialRightImpl(func, placeholderSymbol2, ...partialArgs);
}
function partialRightImpl(func, placeholder, ...partialArgs) {
  const partialedRight = function(...providedArgs) {
    const placeholderLength = partialArgs.filter((arg) => arg === placeholder).length;
    const rangeLength = Math.max(providedArgs.length - placeholderLength, 0);
    const remainingArgs = providedArgs.slice(0, rangeLength);
    let providedArgsIndex = rangeLength;
    const substitutedArgs = partialArgs.slice().map((arg) => arg === placeholder ? providedArgs[providedArgsIndex++] : arg);
    return func.apply(this, remainingArgs.concat(substitutedArgs));
  };
  if (func.prototype) {
    partialedRight.prototype = Object.create(func.prototype);
  }
  return partialedRight;
}
var placeholderSymbol2 = Symbol("partialRight.placeholder");
partialRight.placeholder = placeholderSymbol2;

// node_modules/es-toolkit/dist/function/retry.mjs
var DEFAULT_RETRIES = Number.POSITIVE_INFINITY;

// node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs
function getSymbols(object) {
  return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}

// node_modules/es-toolkit/dist/compat/_internal/getTag.mjs
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}

// node_modules/es-toolkit/dist/compat/_internal/tags.mjs
var regexpTag = "[object RegExp]";
var stringTag = "[object String]";
var numberTag = "[object Number]";
var booleanTag = "[object Boolean]";
var argumentsTag = "[object Arguments]";
var symbolTag = "[object Symbol]";
var dateTag = "[object Date]";
var mapTag = "[object Map]";
var setTag = "[object Set]";
var arrayTag = "[object Array]";
var functionTag = "[object Function]";
var arrayBufferTag = "[object ArrayBuffer]";
var objectTag = "[object Object]";
var errorTag = "[object Error]";
var dataViewTag = "[object DataView]";
var uint8ArrayTag = "[object Uint8Array]";
var uint8ClampedArrayTag = "[object Uint8ClampedArray]";
var uint16ArrayTag = "[object Uint16Array]";
var uint32ArrayTag = "[object Uint32Array]";
var bigUint64ArrayTag = "[object BigUint64Array]";
var int8ArrayTag = "[object Int8Array]";
var int16ArrayTag = "[object Int16Array]";
var int32ArrayTag = "[object Int32Array]";
var bigInt64ArrayTag = "[object BigInt64Array]";
var float32ArrayTag = "[object Float32Array]";
var float64ArrayTag = "[object Float64Array]";

// node_modules/es-toolkit/dist/predicate/isPlainObject.mjs
function isPlainObject(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
  if (!hasObjectPrototype) {
    return false;
  }
  return Object.prototype.toString.call(value) === "[object Object]";
}

// node_modules/es-toolkit/dist/string/words.mjs
var CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");

// node_modules/es-toolkit/dist/_internal/isEqualsSameValueZero.mjs
function isEqualsSameValueZero(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}

// node_modules/es-toolkit/dist/predicate/isEqualWith.mjs
function isEqualWith(a2, b2, areValuesEqual) {
  return isEqualWithImpl(a2, b2, void 0, void 0, void 0, void 0, areValuesEqual);
}
function isEqualWithImpl(a2, b2, property, aParent, bParent, stack, areValuesEqual) {
  const result = areValuesEqual(a2, b2, property, aParent, bParent, stack);
  if (result !== void 0) {
    return result;
  }
  if (typeof a2 === typeof b2) {
    switch (typeof a2) {
      case "bigint":
      case "string":
      case "boolean":
      case "symbol":
      case "undefined": {
        return a2 === b2;
      }
      case "number": {
        return a2 === b2 || Object.is(a2, b2);
      }
      case "function": {
        return a2 === b2;
      }
      case "object": {
        return areObjectsEqual(a2, b2, stack, areValuesEqual);
      }
    }
  }
  return areObjectsEqual(a2, b2, stack, areValuesEqual);
}
function areObjectsEqual(a2, b2, stack, areValuesEqual) {
  if (Object.is(a2, b2)) {
    return true;
  }
  let aTag = getTag(a2);
  let bTag = getTag(b2);
  if (aTag === argumentsTag) {
    aTag = objectTag;
  }
  if (bTag === argumentsTag) {
    bTag = objectTag;
  }
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case stringTag:
      return a2.toString() === b2.toString();
    case numberTag: {
      const x = a2.valueOf();
      const y2 = b2.valueOf();
      return isEqualsSameValueZero(x, y2);
    }
    case booleanTag:
    case dateTag:
    case symbolTag:
      return Object.is(a2.valueOf(), b2.valueOf());
    case regexpTag: {
      return a2.source === b2.source && a2.flags === b2.flags;
    }
    case functionTag: {
      return a2 === b2;
    }
  }
  stack = stack ?? /* @__PURE__ */ new Map();
  const aStack = stack.get(a2);
  const bStack = stack.get(b2);
  if (aStack != null && bStack != null) {
    return aStack === b2;
  }
  stack.set(a2, b2);
  stack.set(b2, a2);
  try {
    switch (aTag) {
      case mapTag: {
        if (a2.size !== b2.size) {
          return false;
        }
        for (const [key, value] of a2.entries()) {
          if (!b2.has(key) || !isEqualWithImpl(value, b2.get(key), key, a2, b2, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case setTag: {
        if (a2.size !== b2.size) {
          return false;
        }
        const aValues = Array.from(a2.values());
        const bValues = Array.from(b2.values());
        for (let i = 0; i < aValues.length; i++) {
          const aValue = aValues[i];
          const index = bValues.findIndex((bValue) => {
            return isEqualWithImpl(aValue, bValue, void 0, a2, b2, stack, areValuesEqual);
          });
          if (index === -1) {
            return false;
          }
          bValues.splice(index, 1);
        }
        return true;
      }
      case arrayTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag:
      case bigUint64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case bigInt64ArrayTag:
      case float32ArrayTag:
      case float64ArrayTag: {
        if (typeof Buffer !== "undefined" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b2)) {
          return false;
        }
        if (a2.length !== b2.length) {
          return false;
        }
        for (let i = 0; i < a2.length; i++) {
          if (!isEqualWithImpl(a2[i], b2[i], i, a2, b2, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      case arrayBufferTag: {
        if (a2.byteLength !== b2.byteLength) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b2), stack, areValuesEqual);
      }
      case dataViewTag: {
        if (a2.byteLength !== b2.byteLength || a2.byteOffset !== b2.byteOffset) {
          return false;
        }
        return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b2), stack, areValuesEqual);
      }
      case errorTag: {
        return a2.name === b2.name && a2.message === b2.message;
      }
      case objectTag: {
        const areEqualInstances = areObjectsEqual(a2.constructor, b2.constructor, stack, areValuesEqual) || isPlainObject(a2) && isPlainObject(b2);
        if (!areEqualInstances) {
          return false;
        }
        const aKeys = [...Object.keys(a2), ...getSymbols(a2)];
        const bKeys = [...Object.keys(b2), ...getSymbols(b2)];
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        for (let i = 0; i < aKeys.length; i++) {
          const propKey = aKeys[i];
          const aProp = a2[propKey];
          if (!Object.hasOwn(b2, propKey)) {
            return false;
          }
          const bProp = b2[propKey];
          if (!isEqualWithImpl(aProp, bProp, propKey, a2, b2, stack, areValuesEqual)) {
            return false;
          }
        }
        return true;
      }
      default: {
        return false;
      }
    }
  } finally {
    stack.delete(a2);
    stack.delete(b2);
  }
}

// node_modules/es-toolkit/dist/predicate/isEqual.mjs
function isEqual(a2, b2) {
  return isEqualWith(a2, b2, noop);
}

// node_modules/minimal-shared/dist/utils/index.js
function p(r) {
  try {
    let t = new URL(r, window.location.origin);
    return Array.from(t.searchParams.keys()).length > 0;
  } catch {
    return false;
  }
}
function a(r) {
  return r !== "/" && r.endsWith("/") ? r.slice(0, -1) : r;
}
function T(r, t, e = { deep: true }) {
  let n = (o) => {
    try {
      let { pathname: i, searchParams: s } = new URL(o.trim(), "http://dummy");
      return e.deep ? { pathname: a(i), params: Object.fromEntries(s) } : { pathname: a(i) };
    } catch {
      return { pathname: "" };
    }
  };
  return isEqual(n(t), n(r));
}
function f(r) {
  try {
    let t = new URL(r, window.location.origin);
    return a(t.pathname);
  } catch {
    return r;
  }
}
function m(r) {
  return /^https?:\/\//i.test(r);
}
function v(r, t) {
  var _a;
  let e = t ?? "/";
  if (!r || typeof window > "u" || !((_a = window.location) == null ? void 0 : _a.origin)) return e;
  try {
    let n = new URL(r, window.location.origin), o = n.origin === window.location.origin, i = n.pathname.startsWith("/") && !n.pathname.startsWith("//"), s = /^\/:+$/.test(n.pathname), u = n.pathname === "/" && !n.search && n.hash;
    return o && i && !s && !u ? `${n.pathname}${n.search}${n.hash}` : e;
  } catch {
    return r.startsWith("/") && !r.startsWith("//") ? r : e;
  }
}
function I(r) {
  return (t) => {
    if (r.length !== 0) for (let e of r) e && (typeof e == "function" ? e(t) : "current" in e && (e.current = t));
  };
}
var g = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"';
function P(r) {
  return r ? `"${r}", ${g}` : g;
}
function R(r) {
  let t = parseFloat(r);
  return Math.round(t * 16);
}
function A(r) {
  if (typeof r != "number" || isNaN(r)) throw new Error(`Invalid pixel value: ${r}`);
  return `${r / 16}rem`;
}
function b(r) {
  if (!r) throw new Error("Hex color is undefined!");
  if (!/^#[0-9A-F]{6}$/i.test(r)) throw new Error(`Invalid hex color: ${r}`);
  let t = parseInt(r.substring(1, 3), 16), e = parseInt(r.substring(3, 5), 16), n = parseInt(r.substring(5, 7), 16);
  return `${t} ${e} ${n}`;
}
function N(r) {
  let t = {};
  return Object.entries(r).forEach(([e, n]) => {
    n && (t[`${e}Channel`] = b(n));
  }), { ...r, ...t };
}
function y(r, t) {
  let e = (i) => i.includes("var(--"), n = (i) => i.trim().endsWith("%"), o = { invalid: `[Alpha]: Invalid opacity "${r}" for ${t}.`, range: "Must be a number between 0 and 1 (e.g., 0.48).", format: 'Must be a percentage (e.g., "48%") or CSS variable (e.g., "var(--opacity)").' };
  if (typeof r == "string") {
    if (n(r)) return r;
    if (e(r)) return `calc(${r} * 100%)`;
    let i = parseFloat(r.trim());
    if (!isNaN(i) && i >= 0 && i <= 1) return `${Number((i * 100).toFixed(2))}%`;
    throw new Error(`${o.invalid} ${o.format}`);
  }
  if (typeof r == "number") {
    if (r >= 0 && r <= 1) return `${Number((r * 100).toFixed(2))}%`;
    throw new Error(`${o.invalid} ${o.range}`);
  }
  throw new Error(`${o.invalid}`);
}
function U(r, t = 1) {
  if (!(r == null ? void 0 : r.trim())) throw new Error("[Alpha]: Color is undefined or empty!");
  if (r.startsWith("#") || r.startsWith("rgb") || r.startsWith("rgba") || !r.includes("var") && r.includes("Channel")) throw new Error([`[Alpha]: Unsupported color format "${r}"`, "✅ Supported formats:", '- RGB channels: "0 184 217"', '- CSS variables with "Channel" prefix: "var(--palette-common-blackChannel, #000000)"', "❌ Unsupported formats:", '- Hex: "#00B8D9"', '- RGB: "rgb(0, 184, 217)"', '- RGBA: "rgba(0, 184, 217, 1)"'].join(`
`));
  let n = y(t, r);
  return r.toLowerCase() === "currentcolor" ? `color-mix(in srgb, currentColor ${n}, transparent)` : `rgba(${r} / ${n})`;
}
function _(r, t) {
  return !r || !t.length || typeof r != "object" ? false : t.every((e) => e in r);
}
function V() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (r) => {
    let t = Math.random() * 16 | 0;
    return (r === "x" ? t : t & 3 | 8).toString(16);
  });
}
function j(r, t) {
  let e = r ? Array.isArray(r) ? r : [r] : [], n = Object.entries(t || {}).filter(([o, i]) => i !== void 0 && i !== false).map(([o, i]) => Array.isArray(i) ? i[0] ? i[1] : "" : i ? o : "").filter(Boolean);
  return [...e.filter(Boolean), ...n].join(" ");
}
function D(r) {
  if (!r || typeof r != "string") return console.warn("Invalid cookie key provided"), null;
  try {
    let t = `${r}=`, o = decodeURIComponent(document.cookie).split("; ").find((s) => s.startsWith(t));
    if (!o) return null;
    let i = o.substring(t.length);
    try {
      return JSON.parse(i);
    } catch {
      return i;
    }
  } catch (t) {
    return console.error("Error retrieving cookie:", t), null;
  }
}
function M(r, t, e) {
  if (!r || typeof r != "string") {
    console.error("Invalid cookie key provided");
    return;
  }
  let { daysUntilExpiration: n = 0, sameSite: o = "Strict", secure: i = false, path: s = "/", domain: u } = e ?? {};
  try {
    let c = encodeURIComponent(typeof t == "string" ? t : JSON.stringify(t)), l = [`${r}=${c}`, `path=${s}`, o && `SameSite=${o}`, i && "Secure", u && `domain=${u}`];
    if (n > 0) {
      let x = new Date(Date.now() + n * 24 * 60 * 60 * 1e3);
      l.push(`expires=${x.toUTCString()}`);
    }
    document.cookie = l.filter(Boolean).join("; ");
  } catch (c) {
    console.error("Error setting cookie:", c);
  }
}
function J(r, t) {
  if (!r || typeof r != "string") {
    console.error("Invalid cookie key provided");
    return;
  }
  let { path: e = "/", domain: n } = t ?? {};
  try {
    let o = [`${r}=`, "expires=Thu, 01 Jan 1970 00:00:00 GMT", `path=${e}`, n && `domain=${n}`, "Secure"];
    document.cookie = o.filter(Boolean).join("; ");
  } catch (o) {
    console.error("Error removing cookie:", o);
  }
}
function H(r, t, e = true) {
  if (!r || !t) return console.warn("isActiveLink: pathname or itemPath is empty!"), false;
  if (t.startsWith("#") || m(t)) return false;
  let n = a(r), o = a(f(t));
  return e || p(t) ? n === o || n.startsWith(`${o}/`) || n.startsWith(`${o}?`) : n === o;
}
function z(r, t) {
  if (!w()) return t ?? null;
  let e = localStorage.getItem(r);
  if (e !== "undefined") {
    if (e) try {
      return JSON.parse(e);
    } catch {
      return e ?? t ?? null;
    }
    return t ?? null;
  }
}
function Y(r, t) {
  try {
    let e = JSON.stringify(t);
    window.localStorage.setItem(r, e);
  } catch (e) {
    console.error("Error while setting storage:", e);
  }
}
function Q(r) {
  try {
    window.localStorage.removeItem(r);
  } catch (t) {
    console.error("Error while removing from storage:", t);
  }
}
function w() {
  try {
    let r = "__some_random_key_you_are_not_going_to_use__";
    return window.localStorage.setItem(r, r), window.localStorage.removeItem(r), true;
  } catch {
    return false;
  }
}
function Z(r) {
  if (typeof r != "string" || !r.trim()) return console.error("Invalid input: CSS value must be a non-empty string"), "";
  let t = r.match(/var\(\s*(--[\w-]+)(?:\s*,[^)]*)?\s*\)/);
  return t ? t[1] : (console.error(`Invalid CSS variable format: "${r}". Expected format: var(--variable-name)`), "");
}
function tr(r) {
  if (typeof r != "string") return console.warn("Invalid CSS value provided"), "";
  let t = r.trim();
  return t ? t.includes("/* @noflip */") ? t : `${t} /* @noflip */` : (console.warn("Empty CSS value provided"), "");
}
function d(r, t = "") {
  return r == null || typeof r == "number" && Number.isNaN(r) ? t : r.toString();
}
function S(r) {
  let e = d(r).replace(/[^0-9.]/g, ""), [n, ...o] = e.split(".");
  return o.length > 0 ? `${n}.${o.join("")}` : n;
}
function $(r, t = "") {
  if (r == null || typeof r == "number" && Number.isNaN(r)) return t;
  let e = parseFloat(r.toString());
  return Number.isNaN(e) ? t : e;
}
var nr = { onChange: S, onBlur: $, value: d };
export {
  N as createPaletteChannel,
  D as getCookie,
  z as getStorage,
  _ as hasKeys,
  p as hasParams,
  b as hexToRgbChannel,
  H as isActiveLink,
  T as isEqualPath,
  m as isExternalLink,
  w as localStorageAvailable,
  j as mergeClasses,
  I as mergeRefs,
  tr as noRtlFlip,
  Z as parseCssVar,
  A as pxToRem,
  R as remToPx,
  J as removeCookie,
  a as removeLastSlash,
  f as removeParams,
  Q as removeStorage,
  v as safeReturnUrl,
  M as setCookie,
  P as setFont,
  Y as setStorage,
  nr as transformNumber,
  d as transformValue,
  $ as transformValueOnBlur,
  S as transformValueOnChange,
  V as uuidv4,
  U as varAlpha
};
//# sourceMappingURL=minimal-shared_utils.js.map
