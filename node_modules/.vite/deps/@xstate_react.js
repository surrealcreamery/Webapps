import {
  require_shim,
  require_with_selector
} from "./chunk-7T2NNKDX.js";
import {
  createActor,
  toObserver
} from "./chunk-OE63YHFF.js";
import {
  require_react
} from "./chunk-ZMLY2J2T.js";
import {
  __toESM
} from "./chunk-4B2QHNJT.js";

// node_modules/@xstate/react/dist/xstate-react.development.esm.js
var React = __toESM(require_react());
var import_react2 = __toESM(require_react());

// node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var import_react = __toESM(require_react());
var index = import_react.useLayoutEffect;

// node_modules/@xstate/react/dist/xstate-react.development.esm.js
var import_with_selector = __toESM(require_with_selector());
var import_shim = __toESM(require_shim());
var forEachActor = (actorRef, callback) => {
  callback(actorRef);
  const children = actorRef.getSnapshot().children;
  if (children) {
    Object.values(children).forEach((child) => {
      forEachActor(child, callback);
    });
  }
};
function stopRootWithRehydration(actorRef) {
  var _a, _b;
  const persistedSnapshots = [];
  forEachActor(actorRef, (ref) => {
    persistedSnapshots.push([ref, ref.getSnapshot()]);
    ref.observers = /* @__PURE__ */ new Set();
  });
  const systemSnapshot = (_b = (_a = actorRef.system).getSnapshot) == null ? void 0 : _b.call(_a);
  actorRef.stop();
  actorRef.system._snapshot = systemSnapshot;
  persistedSnapshots.forEach(([ref, snapshot]) => {
    ref._processingStatus = 0;
    ref._snapshot = snapshot;
  });
}
function useIdleActorRef(logic, ...[options]) {
  let [[currentConfig, actorRef], setCurrent] = (0, import_react2.useState)(() => {
    const actorRef2 = createActor(logic, options);
    return [logic.config, actorRef2];
  });
  if (logic.config !== currentConfig) {
    const newActorRef = createActor(logic, {
      ...options,
      snapshot: actorRef.getPersistedSnapshot({
        __unsafeAllowInlineActors: true
      })
    });
    setCurrent([logic.config, newActorRef]);
    actorRef = newActorRef;
  }
  index(() => {
    actorRef.logic.implementations = logic.implementations;
  });
  return actorRef;
}
function useActorRef(machine, ...[options, observerOrListener]) {
  const actorRef = useIdleActorRef(machine, options);
  (0, import_react2.useEffect)(() => {
    if (!observerOrListener) {
      return;
    }
    const sub = actorRef.subscribe(toObserver(observerOrListener));
    return () => {
      sub.unsubscribe();
    };
  }, [observerOrListener]);
  (0, import_react2.useEffect)(() => {
    actorRef.start();
    return () => {
      stopRootWithRehydration(actorRef);
    };
  }, [actorRef]);
  return actorRef;
}
function defaultCompare(a, b) {
  return a === b;
}
function useSelector(actor, selector, compare = defaultCompare) {
  const subscribe = (0, import_react2.useCallback)((handleStoreChange) => {
    if (!actor) {
      return () => {
      };
    }
    const {
      unsubscribe
    } = actor.subscribe(handleStoreChange);
    return unsubscribe;
  }, [actor]);
  const boundGetSnapshot = (0, import_react2.useCallback)(() => actor == null ? void 0 : actor.getSnapshot(), [actor]);
  const selectedSnapshot = (0, import_with_selector.useSyncExternalStoreWithSelector)(subscribe, boundGetSnapshot, boundGetSnapshot, selector, compare);
  return selectedSnapshot;
}
function createActorContext(actorLogic, actorOptions) {
  const ReactContext = React.createContext(null);
  const OriginalProvider = ReactContext.Provider;
  function Provider({
    children,
    logic: providedLogic = actorLogic,
    machine,
    options: providedOptions
  }) {
    if (machine) {
      throw new Error(`The "machine" prop has been deprecated. Please use "logic" instead.`);
    }
    const actor = useActorRef(providedLogic, {
      ...actorOptions,
      ...providedOptions
    });
    return React.createElement(OriginalProvider, {
      value: actor,
      children
    });
  }
  Provider.displayName = `ActorProvider`;
  function useContext2() {
    const actor = React.useContext(ReactContext);
    if (!actor) {
      throw new Error(`You used a hook from "${Provider.displayName}" but it's not inside a <${Provider.displayName}> component.`);
    }
    return actor;
  }
  function useSelector$1(selector, compare) {
    const actor = useContext2();
    return useSelector(actor, selector, compare);
  }
  return {
    Provider,
    useActorRef: useContext2,
    useSelector: useSelector$1
  };
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
function useActor(logic, ...[options]) {
  if (!!logic && "send" in logic && typeof logic.send === "function") {
    throw new Error(`useActor() expects actor logic (e.g. a machine), but received an ActorRef. Use the useSelector(actorRef, ...) hook instead to read the ActorRef's snapshot.`);
  }
  const actorRef = useIdleActorRef(logic, options);
  const getSnapshot = (0, import_react2.useCallback)(() => {
    return actorRef.getSnapshot();
  }, [actorRef]);
  const subscribe = (0, import_react2.useCallback)((handleStoreChange) => {
    const {
      unsubscribe
    } = actorRef.subscribe(handleStoreChange);
    return unsubscribe;
  }, [actorRef]);
  const actorSnapshot = (0, import_shim.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);
  (0, import_react2.useEffect)(() => {
    actorRef.start();
    return () => {
      stopRootWithRehydration(actorRef);
    };
  }, [actorRef]);
  return [actorSnapshot, actorRef.send, actorRef];
}
function useMachine(machine, ...[options]) {
  return useActor(machine, options);
}
export {
  createActorContext,
  shallowEqual,
  useActor,
  useActorRef,
  useMachine,
  useSelector
};
//# sourceMappingURL=@xstate_react.js.map
